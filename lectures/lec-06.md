# Лекція 06 Інтеграція систем та API

## Вступ

Сучасні бізнес-процеси неможливо уявити без взаємодії різних інформаційних систем. Організації використовують десятки різних додатків: ERP для управління ресурсами, CRM для роботи з клієнтами, системи обліку, платіжні сервіси, системи аналітики. Кожна з цих систем зберігає важливі дані та виконує специфічні функції. Інтеграція цих систем дозволяє автоматизувати обмін даними, уникнути дублювання інформації та створити єдиний інформаційний простір підприємства.

У цій лекції ми розглянемо основні технології та підходи до інтеграції бізнес-систем. Особливу увагу приділимо REST API як найпоширенішому способу взаємодії між додатками, вивчимо концепцію вебхуків та подієвої архітектури, познайомимося з мікросервісним підходом до побудови систем та розглянемо роль черг повідомлень у забезпеченні надійної комунікації між компонентами.

## REST API: основи взаємодії між системами

### Що таке API

API (Application Programming Interface) - це інтерфейс програмування додатків, набір правил та протоколів, які визначають, як різні програмні компоненти мають взаємодіяти між собою. API можна розглядати як договір між двома системами про те, які дані можна запитувати, в якому форматі їх передавати та які відповіді очікувати.

Уявімо ресторан як аналогію. Відвідувач не заходить на кухню та не готує їжу самостійно. Натомість він взаємодіє з офіціантом, який приймає замовлення, передає його на кухню та приносить готову страву. Офіціант у цій аналогії виступає API - посередником між клієнтом та системою, яка виконує роботу. Меню ресторану це документація API, яка описує доступні опції та формат замовлення.

### Архітектурний стиль REST

REST (Representational State Transfer) - це архітектурний стиль побудови вебсервісів, запропонований Роєм Філдінгом у 2000 році. REST визначає набір принципів, які роблять API простими, масштабованими та зручними у використанні.

Ключові принципи REST включають клієнт-серверну архітектуру, де клієнт та сервер розділені і можуть розвиватися незалежно один від одного. Взаємодія відбувається без збереження стану (stateless), що означає, що кожен запит від клієнта містить всю необхідну інформацію для його обробки, а сервер не зберігає контекст між запитами. Це спрощує масштабування системи, оскільки будь-який сервер може обробити будь-який запит.

REST використовує стандартні HTTP методи для виконання операцій над ресурсами. Ресурс - це будь-який об'єкт або дані, з якими працює API. Це може бути користувач, замовлення, продукт, документ. Кожен ресурс має унікальний ідентифікатор (URI) та представлення, зазвичай у форматі JSON або XML.

### HTTP методи та їх семантика

REST API використовує стандартні HTTP методи, кожен з яких має чітко визначену семантику:

GET використовується для отримання даних. Цей метод є безпечним (не змінює стан ресурсу) та ідемпотентним (повторні виклики дають той самий результат). Приклад запиту для отримання інформації про користувача:

```
GET /api/users/12345
```

POST використовується для створення нових ресурсів. Кожен виклик POST зазвичай створює новий ресурс з унікальним ідентифікатором. Приклад створення нового замовлення:

```
POST /api/orders
Content-Type: application/json

{
  "customer_id": "67890",
  "items": [
    {"product_id": "ABC", "quantity": 2},
    {"product_id": "XYZ", "quantity": 1}
  ]
}
```

PUT використовується для повного оновлення існуючого ресурсу або створення ресурсу з визначеним ідентифікатором. Метод є ідемпотентним - повторні виклики з тими самими даними призводять до того самого стану ресурсу:

```
PUT /api/users/12345
Content-Type: application/json

{
  "name": "Іван Петренко",
  "email": "ivan@example.com",
  "role": "manager"
}
```

PATCH використовується для часткового оновлення ресурсу, коли потрібно змінити лише окремі поля:

```
PATCH /api/users/12345
Content-Type: application/json

{
  "email": "new-email@example.com"
}
```

DELETE видаляє ресурс. Метод також є ідемпотентним - повторне видалення того самого ресурсу не змінює кінцевий результат:

```
DELETE /api/orders/98765
```

### Структура URL та іменування ресурсів

Правильна структура URL робить API інтуїтивним та зручним у використанні. Основні принципи іменування включають використання іменників замість дієслів, оскільки дію визначає HTTP метод. Ресурси мають іменуватися у множині для консистентності. Ієрархія ресурсів відображається у структурі URL.

Приклади добре структурованих URL:

```
GET /api/customers - отримати список клієнтів
GET /api/customers/123 - отримати клієнта з id 123
GET /api/customers/123/orders - отримати замовлення клієнта 123
GET /api/customers/123/orders/456 - отримати конкретне замовлення
POST /api/customers/123/orders - створити нове замовлення для клієнта
```

Для складних запитів використовуються параметри запиту (query parameters):

```
GET /api/products?category=electronics&price_max=1000&sort=price_asc
GET /api/orders?status=pending&created_after=2024-01-01&page=2&limit=20
```

### Коди відповідей HTTP

Сервер використовує стандартні коди відповідей HTTP для повідомлення про результат обробки запиту. Коди групуються за категоріями:

Коди 2xx вказують на успішне виконання запиту. Код 200 OK означає успішну обробку запиту GET, PUT або PATCH. Код 201 Created повертається після успішного створення ресурсу методом POST, зазвичай з заголовком Location, що вказує на URL нового ресурсу. Код 204 No Content використовується для успішних операцій, які не повертають даних, наприклад DELETE.

Коди 4xx вказують на помилки клієнта. Код 400 Bad Request означає некоректний формат запиту. Код 401 Unauthorized сигналізує про відсутність автентифікації. Код 403 Forbidden означає, що користувач автентифікований, але не має прав на цю операцію. Код 404 Not Found вказує, що ресурс не знайдено. Код 409 Conflict виникає при конфліктах, наприклад, спробі створити ресурс, який вже існує.

Коди 5xx вказують на помилки сервера. Код 500 Internal Server Error означає внутрішню помилку сервера. Код 503 Service Unavailable вказує, що сервіс тимчасово недоступний.

### Формат даних JSON

JSON (JavaScript Object Notation) став де-факто стандартом для обміну даними у REST API завдяки своїй простоті та читабельності. JSON підтримує основні типи даних: об'єкти, масиви, рядки, числа, булеві значення та null.

Приклад відповіді API з інформацією про користувача:

```json
{
  "id": 12345,
  "username": "ivan_petrenko",
  "email": "ivan@example.com",
  "profile": {
    "first_name": "Іван",
    "last_name": "Петренко",
    "date_of_birth": "1995-03-15",
    "city": "Київ"
  },
  "roles": ["user", "moderator"],
  "active": true,
  "created_at": "2023-01-10T14:30:00Z",
  "last_login": "2024-02-08T09:15:32Z"
}
```

Приклад списку ресурсів з метаданими пагінації:

```json
{
  "data": [
    {
      "id": 1,
      "title": "Ноутбук Dell XPS 15",
      "price": 45000,
      "in_stock": true
    },
    {
      "id": 2,
      "title": "Монітор LG 27 inch",
      "price": 12000,
      "in_stock": false
    }
  ],
  "pagination": {
    "page": 1,
    "per_page": 20,
    "total": 156,
    "total_pages": 8
  }
}
```

### Автентифікація та авторизація

Більшість API вимагають автентифікації для ідентифікації клієнта та авторизації для перевірки прав доступу. Розглянемо основні підходи до автентифікації.

API ключі - найпростіший метод автентифікації. Клієнт отримує унікальний ключ та передає його з кожним запитом у заголовку або параметрі URL:

```
GET /api/weather?city=Kyiv&apikey=abc123def456
```

Або у заголовку:

```
GET /api/users
X-API-Key: abc123def456
```

API ключі прості у реалізації, але мають обмеження. Вони не ідентифікують конкретного користувача, а лише додаток. Компрометація ключа вимагає його заміни у всіх місцях використання.

Bearer Token (OAuth 2.0) - більш сучасний та безпечний підхід. Клієнт спочатку отримує токен доступу через процес автентифікації, а потім використовує цей токен для авторизації запитів:

```
POST /oauth/token
Content-Type: application/x-www-form-urlencoded

grant_type=client_credentials&
client_id=my_app&
client_secret=secret123
```

Відповідь:

```json
{
  "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "token_type": "Bearer",
  "expires_in": 3600
}
```

Використання токену:

```
GET /api/users/me
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
```

JWT (JSON Web Token) часто використовується як формат токену. JWT містить закодовану інформацію про користувача та права доступу, що дозволяє серверу перевіряти права без звернення до бази даних.

Basic Authentication передає логін та пароль у кожному запиті, закодовані у base64:

```
GET /api/users
Authorization: Basic dXNlcm5hbWU6cGFzc3dvcmQ=
```

Цей метод простий, але небезпечний без HTTPS, оскільки base64 легко декодується. Використовується переважно для внутрішніх систем або разом з HTTPS.

### Обробка помилок

Якісний API повинен надавати зрозумілі повідомлення про помилки. Структурована відповідь з помилкою може виглядати так:

```json
{
  "error": {
    "code": "VALIDATION_ERROR",
    "message": "Некоректні дані запиту",
    "details": [
      {
        "field": "email",
        "message": "Невірний формат email адреси"
      },
      {
        "field": "age",
        "message": "Вік має бути більше 18"
      }
    ],
    "request_id": "req_abc123",
    "timestamp": "2024-02-08T10:30:45Z"
  }
}
```

Такий формат дозволяє клієнту програмно обробляти помилки, показувати користувачам зрозумілі повідомлення та логувати деталі для налагодження.

### Версіонування API

API розвиваються з часом, і важливо забезпечити зворотну сумісність або коректно повідомляти про зміни. Існує кілька підходів до версіонування.

Версіонування через URL - найпоширеніший підхід:

```
https://api.example.com/v1/users
https://api.example.com/v2/users
```

Версіонування через заголовки:

```
GET /api/users
Accept: application/vnd.company.v2+json
```

Версіонування через параметр запиту:

```
GET /api/users?version=2
```

Кожен підхід має переваги та недоліки. URL версіонування найпростіше для розуміння та кешування, але створює дублювання коду. Версіонування через заголовки технічно більш коректне, але менш очевидне для розробників.

## Webhook та подієва архітектура

### Концепція вебхуків

Традиційна взаємодія з API відбувається за моделлю запит-відповідь (polling). Клієнт періодично запитує сервер, чи з'явилися нові дані. Це неефективно, оскільки більшість запитів повертають порожній результат, витрачаючи ресурси сервера та створюючи затримки.

Webhook (вебхук) - це механізм push-повідомлень, де сервер сам надсилає дані клієнту, коли відбувається певна подія. Замість того, щоб клієнт постійно питав "чи є нові дані?", сервер повідомляє "ось нові дані, щойно з'явилися".

Механізм роботи вебхуку включає такі кроки. Клієнт реєструє webhook URL (endpoint), куди сервер має надсилати повідомлення. Коли на сервері відбувається подія (створення замовлення, зміна статусу, новий коментар), сервер робить HTTP POST запит на зареєстрований URL з даними про подію. Клієнт отримує та обробляє дані, повертаючи статус 200 OK для підтвердження.

### Практичні приклади використання вебхуків

Платіжні системи використовують вебхуки для повідомлення про статус платежів. Наприклад, після обробки платежу Stripe надсилає вебхук:

```json
POST https://your-site.com/webhooks/stripe
Content-Type: application/json

{
  "id": "evt_1234567890",
  "type": "payment_intent.succeeded",
  "data": {
    "object": {
      "id": "pi_abc123",
      "amount": 5000,
      "currency": "uah",
      "customer": "cus_xyz789",
      "status": "succeeded"
    }
  },
  "created": 1707389445
}
```

Ваша система отримує це повідомлення та може автоматично оновити статус замовлення, надіслати email клієнту, оновити складські залишки.

GitHub використовує вебхуки для інтеграцій. Коли хтось створює pull request, GitHub може надіслати webhook вашій CI/CD системі для автоматичного запуску тестів:

```json
{
  "action": "opened",
  "pull_request": {
    "id": 123,
    "title": "Fix authentication bug",
    "user": {
      "login": "developer123"
    },
    "head": {
      "ref": "fix-auth-bug",
      "sha": "abc123def456"
    }
  },
  "repository": {
    "name": "my-project",
    "full_name": "company/my-project"
  }
}
```

### Безпека вебхуків

Вебхуки створюють певні ризики безпеки, оскільки ваша система приймає запити ззовні. Критично важливо перевіряти, що запит справді надійшов від легітимного джерела.

Підпис запиту (signature verification) - стандартний метод автентифікації вебхуків. Сервер обчислює HMAC хеш тіла запиту з використанням секретного ключа та додає його до заголовка:

```
X-Webhook-Signature: sha256=5d41402abc4b2a76b9719d911017c592
```

Ваша система обчислює той самий хеш та порівнює з отриманим. Якщо вони співпадають, запит автентичний.

Приклад перевірки підпису на Python:

```python
import hmac
import hashlib

def verify_webhook(payload, signature, secret):
    computed_signature = hmac.new(
        secret.encode(),
        payload.encode(),
        hashlib.sha256
    ).hexdigest()

    return hmac.compare_digest(
        f"sha256={computed_signature}",
        signature
    )
```

Додаткові заходи безпеки включають використання HTTPS для шифрування трафіку, валідацію структури даних перед обробкою, обмеження IP адрес, з яких приймаються вебхуки, timeout для обробки запитів щоб уникнути DoS атак.

### Retry механізми та ідемпотентність

Мережеві помилки неминучі. Ваш сервер може бути тимчасово недоступний під час обслуговування або навантаження. Тому системи, що надсилають вебхуки, зазвичай реалізують механізм повторних спроб (retry).

Типова стратегія retry включає експоненційну затримку між спробами: перша повторна спроба через 1 хвилину, друга через 5 хвилин, третя через 15 хвилин, четверта через 1 годину. Після певної кількості невдалих спроб (наприклад, 5) вебхук вважається failed і вимагає ручного втручання.

Це створює важливу вимогу до обробників вебхуків - ідемпотентність. Ваш код має коректно обробляти повторне отримання того самого вебхука. Використовуйте унікальний ідентифікатор події для відстеження вже оброблених повідомлень:

```python
def handle_payment_webhook(event_id, payment_data):
    # Перевірка, чи вже обробляли цю подію
    if ProcessedEvent.objects.filter(event_id=event_id).exists():
        return {"status": "already_processed"}

    # Обробка платежу
    update_order_status(payment_data)
    send_confirmation_email(payment_data)

    # Збереження ID обробленої події
    ProcessedEvent.objects.create(event_id=event_id)

    return {"status": "success"}
```

### Подієва архітектура (Event-Driven Architecture)

Вебхуки є проявом ширшої концепції подієвої архітектури. У такій архітектурі компоненти системи взаємодіють через події - повідомлення про те, що щось сталося. Компоненти не викликають один одного безпосередньо, а публікують події та підписуються на події, які їх цікавлять.

Переваги подієвої архітектури включають слабке зв'язування компонентів - системи не залежать від деталей реалізації один одного. Масштабованість забезпечується можливістю додавати нові обробники подій без зміни публікаторів. Гнучкість дозволяє легко розширювати функціональність додаванням нових підписників. Асинхронність означає, що публікатор не чекає на обробку події всіма підписниками.

Приклад подієвої системи обробки замовлень:

```mermaid
graph LR
    A[Веб-додаток] -->|OrderCreated| B[Event Bus]
    B -->|OrderCreated| C[Inventory Service]
    B -->|OrderCreated| D[Payment Service]
    B -->|OrderCreated| E[Notification Service]
    B -->|OrderCreated| F[Analytics Service]

    C -->|InventoryReserved| B
    D -->|PaymentProcessed| B
    B -->|PaymentProcessed| G[Shipping Service]
```

Коли користувач створює замовлення, генерується подія OrderCreated. Різні сервіси підписані на цю подію: Inventory Service резервує товар, Payment Service обробляє платіж, Notification Service надсилає email підтвердження, Analytics Service оновлює статистику. Кожен сервіс працює незалежно і може бути масштабований окремо.

## Мікросервісна архітектура

### Від монолітів до мікросервісів

Традиційні додатки будуються як монолітна система - єдина кодова база, яка містить всю бізнес-логіку. У невеликих проєктах це працює добре, але зі зростанням складності виникають проблеми. Зміни в одній частині системи вимагають повторного розгортання всього додатка. Масштабування можливе лише вертикально (потужніший сервер) або реплікацією всього монолітного додатка. Технологічний стек фіксований для всього проєкту. Складність коду зростає, утруднюючи розуміння та підтримку.

Мікросервісна архітектура розбиває додаток на набір невеликих, незалежних сервісів. Кожен сервіс відповідає за конкретну бізнес-функцію, має власну базу даних, може бути написаний різними технологіями, розгортається та масштабується незалежно.

Характеристики мікросервісу включають відповідальність за одну бізнес-можливість (наприклад, управління користувачами, обробка платежів, управління каталогом). Автономність означає власну базу даних та незалежність від інших сервісів. Розгортання виконується незалежно без впливу на інші сервіси. Комунікація відбувається через добре визначені API або події.

### Приклад мікросервісної архітектури

Розглянемо архітектуру інтернет-магазину:

```mermaid
graph TB
    A[API Gateway] --> B[User Service]
    A --> C[Product Service]
    A --> D[Order Service]
    A --> E[Payment Service]
    A --> F[Shipping Service]

    B --> B1[(User DB)]
    C --> C1[(Product DB)]
    D --> D1[(Order DB)]
    E --> E2[Stripe API]
    F --> F2[Nova Poshta API]

    D -.订阅事件.-> G[Event Bus]
    E -.публікує події.-> G
    F -.підписка.-> G
```

User Service управляє автентифікацією, профілями користувачів, правами доступу. Використовує PostgreSQL для зберігання даних користувачів.

Product Service керує каталогом товарів, категоріями, цінами, наявністю. Може використовувати MongoDB для гнучкої структури даних товарів.

Order Service обробляє створення та управління замовленнями, відстежує статуси. Використовує PostgreSQL з транзакціями для забезпечення консистентності.

Payment Service інтегрується з платіжними системами (Stripe, LiqPay), обробляє платежі, повернення коштів.

Shipping Service розраховує вартість доставки, створює накладні, відстежує статус відправлень. Інтегрується з API служб доставки.

API Gateway виступає єдиною точкою входу для клієнтів, маршрутизує запити до відповідних сервісів, може виконувати автентифікацію та rate limiting.

### Переваги та виклики мікросервісів

Переваги мікросервісної архітектури включають незалежне масштабування кожного сервіса окремо залежно від навантаження. Технологічна різноманітність дозволяє обирати оптимальний стек для кожного сервіса. Ізоляція збоїв означає, що проблеми в одному сервісі не зупиняють всю систему. Незалежні команди можуть працювати над різними сервісами паралельно. Швидке розгортання дозволяє оновлювати окремі сервіси без зупинки всієї системи.

Проте мікросервіси створюють додаткову складність. Мережева взаємодія між сервісами вносить латентність та можливі збої. Розподілені транзакції складно реалізувати - якщо Order Service створив замовлення, але Payment Service не зміг обробити платіж, потрібні механізми компенсації. Моніторинг та логування ускладнюються через розподіленість системи. Управління даними стає складнішим, оскільки кожен сервіс має власну базу даних. Тестування вимагає координації між сервісами.

### Комунікація між мікросервісами

Мікросервіси можуть взаємодіяти синхронно або асинхронно. Синхронна комунікація відбувається через REST API або gRPC. Сервіс робить запит та чекає на відповідь. Це простіше для розуміння, але створює тісне зв'язування та залежності.

Приклад синхронного виклику:

```python
# Order Service викликає Product Service
def create_order(product_id, quantity):
    # Синхронний запит до Product Service
    product = requests.get(
        f"http://product-service/api/products/{product_id}"
    ).json()

    if product["stock"] < quantity:
        raise InsufficientStock()

    # Резервування товару
    requests.post(
        f"http://product-service/api/products/{product_id}/reserve",
        json={"quantity": quantity}
    )

    # Створення замовлення
    order = Order.create(product_id=product_id, quantity=quantity)
    return order
```

Асинхронна комунікація використовує події та черги повідомлень. Сервіс публікує подію і продовжує роботу, не чекаючи на обробку:

```python
# Order Service публікує подію
def create_order(product_id, quantity):
    order = Order.create(product_id=product_id, quantity=quantity)

    # Публікація події OrderCreated
    event_bus.publish("OrderCreated", {
        "order_id": order.id,
        "product_id": product_id,
        "quantity": quantity,
        "customer_id": customer_id
    })

    return order

# Inventory Service підписаний на OrderCreated
@event_bus.subscribe("OrderCreated")
def handle_order_created(event):
    reserve_inventory(
        event["product_id"],
        event["quantity"]
    )

# Payment Service також підписаний на OrderCreated
@event_bus.subscribe("OrderCreated")
def handle_order_created(event):
    process_payment(
        event["order_id"],
        event["customer_id"]
    )
```

### Паттерни мікросервісів

API Gateway - єдина точка входу для всіх клієнтських запитів. Маршрутизує запити до відповідних сервісів, виконує автентифікацію, агрегує відповіді від кількох сервісів, забезпечує rate limiting та кешування.

Service Discovery - механізм автоматичного виявлення сервісів. У динамічному середовищі (Kubernetes, Docker Swarm) сервіси можуть переміщатися між серверами. Service Discovery (Consul, Eureka) дозволяє сервісам знаходити один одного без жорстко закодованих адрес.

Circuit Breaker - паттерн для обробки збоїв. Якщо сервіс постійно падає, Circuit Breaker "розмикає ланцюг" і перестає надсилати запити, повертаючи помилку відразу. Це запобігає каскадним збоям і дає час проблемному сервісу відновитися.

Saga Pattern - паттерн для розподілених транзакцій. Замість однієї великої транзакції, операція розбивається на послідовність локальних транзакцій у різних сервісах. Якщо одна з транзакцій не виконується, виконуються компенсуючі транзакції для відкату змін.

## Черги повідомлень (Message Queues)

### Призначення черг повідомлень

Черги повідомлень забезпечують асинхронну комунікацію між компонентами системи. Відправник (producer) надсилає повідомлення у чергу і продовжує роботу, не чекаючи на обробку. Отримувач (consumer) забирає повідомлення з черги та обробляє його у зручний час.

Основні переваги використання черг включають розділення у часі - відправник та отримувач не повинні працювати одночасно. Буферизація навантаження означає, що черга поглинає піки навантаження, а споживачі обробляють повідомлення з комфортною швидкістю. Надійність забезпечується зберіганням повідомлень до успішної обробки. Масштабованість дозволяє додавати споживачів для паралельної обробки. Відмовостійкість означає, що якщо споживач падає, повідомлення залишається у черзі.

### Архітектура систем черг

Базова архітектура включає продюсера, який створює та надсилає повідомлення. Брокер повідомлень (RabbitMQ, Kafka) приймає, зберігає та доставляє повідомлення. Консьюмер отримує та обробляє повідомлення.

```mermaid
graph LR
    A[Producer 1] -->|publish| B[Message Queue]
    A2[Producer 2] -->|publish| B
    B -->|consume| C[Consumer 1]
    B -->|consume| C2[Consumer 2]
    B -->|consume| C3[Consumer 3]
```

Повідомлення зберігається у черзі до підтвердження обробки (acknowledgment). Якщо споживач падає перед підтвердженням, повідомлення повертається у чергу для повторної обробки.

### RabbitMQ - класичний брокер повідомлень

RabbitMQ реалізує протокол AMQP (Advanced Message Queuing Protocol) та підтримує різні патерни обміну повідомленнями.

Основні компоненти RabbitMQ включають продюсера, який публікує повідомлення. Exchange приймає повідомлення від продюсера та маршрутизує їх до черг за правилами. Queue зберігає повідомлення до обробки. Консьюмер підписується на чергу та обробляє повідомлення. Binding визначає правила маршрутизації між exchange та queue.

Типи exchange визначають логіку маршрутизації. Direct exchange доставляє повідомлення до черги, якщо routing key точно співпадає:

```python
# Продюсер надсилає повідомлення з routing key "error"
channel.basic_publish(
    exchange='logs',
    routing_key='error',
    body='Critical error occurred'
)

# Черга прив'язана до exchange з routing key "error"
channel.queue_bind(
    exchange='logs',
    queue='error_logs',
    routing_key='error'
)
```

Topic exchange використовує шаблони для routing key. Символ # означає будь-яку послідовність слів, символ * означає одне слово:

```python
# Публікація з різними routing keys
channel.basic_publish(exchange='logs', routing_key='error.payment', body='msg')
channel.basic_publish(exchange='logs', routing_key='info.auth', body='msg')
channel.basic_publish(exchange='logs', routing_key='warning.database', body='msg')

# Черга отримує всі error повідомлення
channel.queue_bind(exchange='logs', queue='errors', routing_key='error.*')

# Черга отримує всі повідомлення про платежі
channel.queue_bind(exchange='logs', queue='payments', routing_key='*.payment')

# Черга отримує всі повідомлення
channel.queue_bind(exchange='logs', queue='all_logs', routing_key='#')
```

Fanout exchange доставляє повідомлення до всіх прив'язаних черг, ігноруючи routing key. Використовується для broadcasting.

Приклад використання RabbitMQ для обробки email повідомлень:

```python
import pika

# Продюсер
connection = pika.BlockingConnection(
    pika.ConnectionParameters('localhost')
)
channel = connection.channel()

# Створення черги
channel.queue_declare(queue='emails', durable=True)

# Публікація повідомлення
message = {
    "to": "user@example.com",
    "subject": "Order confirmation",
    "body": "Your order has been confirmed"
}

channel.basic_publish(
    exchange='',
    routing_key='emails',
    body=json.dumps(message),
    properties=pika.BasicProperties(
        delivery_mode=2,  # Зробити повідомлення persistent
    )
)

# Консьюмер
def callback(ch, method, properties, body):
    email_data = json.loads(body)
    send_email(
        to=email_data["to"],
        subject=email_data["subject"],
        body=email_data["body"]
    )
    # Підтвердження обробки
    ch.basic_ack(delivery_tag=method.delivery_tag)

channel.basic_qos(prefetch_count=1)  # Обробляти по одному повідомленню
channel.basic_consume(queue='emails', on_message_callback=callback)
channel.start_consuming()
```

### Apache Kafka - розподілена платформа стрімінгу

Kafka розроблена для обробки величезних обсягів даних у реальному часі. На відміну від традиційних черг, Kafka зберігає повідомлення як потік подій (event log) та дозволяє кільком споживачам читати ті самі дані незалежно.

Архітектура Kafka включає топіки, які є категоріями або потоками повідомлень. Партиції діляють топік на частини для паралельної обробки. Продюсери публікують повідомлення у топіки. Консьюмери підписуються на топіки та обробляють повідомлення. Брокери - це сервери Kafka, які зберігають дані. ZooKeeper координує кластер Kafka.

```mermaid
graph TB
    P1[Producer 1] -->|write| T[Topic: orders]
    P2[Producer 2] -->|write| T

    T --> Part1[Partition 0]
    T --> Part2[Partition 1]
    T --> Part3[Partition 2]

    Part1 --> CG1[Consumer Group 1]
    Part2 --> CG1
    Part3 --> CG1

    Part1 --> CG2[Consumer Group 2]
    Part2 --> CG2
    Part3 --> CG2
```

Ключові відмінності Kafka від RabbitMQ включають збереження повідомлень. Kafka зберігає всі повідомлення певний час (наприклад, 7 днів), навіть після обробки. Consumer Groups дозволяють кільком споживачам обробляти той самий топік паралельно. Високу пропускну здатність - Kafka оптимізована для мільйонів повідомлень на секунду. Replay можливість - споживач може перечитати історичні дані.

Приклад використання Kafka:

```python
from kafka import KafkaProducer, KafkaConsumer
import json

# Продюсер
producer = KafkaProducer(
    bootstrap_servers=['localhost:9092'],
    value_serializer=lambda v: json.dumps(v).encode('utf-8')
)

# Публікація події
event = {
    "event_type": "order_created",
    "order_id": "12345",
    "customer_id": "67890",
    "timestamp": "2024-02-08T10:30:00Z"
}

producer.send('orders', value=event)
producer.flush()

# Консьюмер
consumer = KafkaConsumer(
    'orders',
    bootstrap_servers=['localhost:9092'],
    group_id='analytics-service',
    value_deserializer=lambda m: json.loads(m.decode('utf-8'))
)

for message in consumer:
    event = message.value
    print(f"Processing order: {event['order_id']}")
    update_analytics(event)
```

### Вибір між RabbitMQ та Kafka

RabbitMQ краще підходить для задач, де потрібна складна маршрутизація повідомлень з різними патернами. Повідомлення обробляються один раз та видаляються. Менший обсяг повідомлень (тисячі на секунду). Потрібні гарантії доставки та підтвердження обробки. Традиційні задачі черг (email, фонові задачі, job processing).

Kafka оптимальна для потокової обробки великих обсягів даних. Event sourcing та збереження історії подій. Потрібна можливість повторного читання даних. Високе навантаження (мільйони повідомлень). Аналітика та моніторинг у реальному часі. Реплікація даних між системами.

## Практика інтеграції бізнес-систем

### Типові сценарії інтеграції

Інтеграція CRM та email маркетингу дозволяє автоматично синхронізувати контакти між Salesforce та Mailchimp, створювати сегменти для розсилок на основі даних CRM, відстежувати відкриття листів та оновлювати CRM.

Інтеграція інтернет-магазину та складського обліку синхронізує залишки товарів, автоматично створює накладні на відвантаження при оформленні замовлення, оновлює статуси доставки.

Інтеграція платіжної системи з бухгалтерією автоматично створює записи про платежі у бухгалтерській системі, звіряє платежі з рахунками, генерує фінансові звіти.

### Побудова інтеграційного middleware

Для складних інтеграцій часто створюється проміжний шар (middleware), який виконує трансформацію даних, маршрутизацію, обробку помилок.

Приклад інтеграційного сервісу на n8n (low-code платформа):

Workflow отримує вебхук про нове замовлення з інтернет-магазину. Витягує дані клієнта та перевіряє, чи існує у CRM. Якщо ні - створює новий контакт. Створює запис про замовлення у CRM. Надсилає дані у складську систему для резервування товарів. Ініціює обробку платежу через платіжний gateway. Надсилає підтвердження клієнту через email та SMS. Записує подію у аналітичну систему.

### Моніторинг та логування інтеграцій

Критично важливо відстежувати стан інтеграцій, оскільки збої можуть призвести до втрати даних або неконсистентності.

Ключові метрики моніторингу включають кількість успішних та невдалих запитів, час відповіді API, кількість повідомлень у чергах, затримки обробки, rate limit violations.

Структуроване логування допомагає відстежувати потік даних:

```python
import logging
import json

logger = logging.getLogger(__name__)

def sync_order_to_crm(order_id):
    logger.info(
        "Starting CRM sync",
        extra={
            "order_id": order_id,
            "action": "crm_sync_start"
        }
    )

    try:
        order_data = get_order(order_id)
        crm_response = crm_api.create_deal(order_data)

        logger.info(
            "CRM sync successful",
            extra={
                "order_id": order_id,
                "crm_deal_id": crm_response["id"],
                "action": "crm_sync_success"
            }
        )

    except Exception as e:
        logger.error(
            "CRM sync failed",
            extra={
                "order_id": order_id,
                "error": str(e),
                "action": "crm_sync_error"
            }
        )
        raise
```

Alerting налаштовується для критичних ситуацій: rate limit перевищено, черга переповнена, високий відсоток помилок, час відповіді API перевищує граничні значення.

### Тестування інтеграцій

Тестування інтеграцій складніше за тестування окремих компонентів. Contract testing використовує Pact для визначення контракту між сервісами та перевірки його дотримання. Integration tests тестують взаємодію між реальними компонентами. End-to-end tests перевіряють повний сценарій бізнес-процесу. Mock servers використовуються для імітації зовнішніх API під час розробки.

## Висновки

Інтеграція систем є критично важливою складовою сучасних бізнес-процесів. REST API забезпечує стандартизований спосіб взаємодії між додатками через HTTP протокол, використовуючи зрозумілі методи та формати даних. Вебхуки та подієва архітектура дозволяють системам реагувати на зміни в реальному часі без постійного опитування.

Мікросервісна архітектура розбиває монолітні додатки на незалежні сервіси, що покращує масштабованість та гнучкість, хоча й додає складності у комунікації та управлінні. Черги повідомлень забезпечують надійну асинхронну комунікацію, буферизацію навантаження та відмовостійкість систем.

Успішна інтеграція вимагає ретельного планування архітектури, вибору правильних технологій для конкретних завдань, забезпечення безпеки через автентифікацію та шифрування, моніторингу та логування для виявлення проблем, тестування на всіх рівнях від unit до end-to-end.

Розуміння принципів інтеграції систем дозволяє створювати надійні, масштабовані та безпечні бізнес-процеси, які ефективно використовують можливості різних спеціалізованих систем.
